# スライス
可変長配列と同等の機能を有するGo言語の型

スライスは、配列に対して
- 配列全体のポインタ(ptr)
- 配列の長さ(len)
- 配列の容量(cap)
- をもつ。

- appendはあるが、deleteがないので注意。


## 宣言
可変長扱いなので、要素数は不要。
```
var foo []int
var foo = []int{1, 2, 3}
foo := []int{1, 2, 3, 4, 5, 6, 7}
```

## 操作

```
全要素を指定して代入。スライスのコピー。値が共有される。
bar := a[:]


# 長さ
len(foo)
# 容量
cap(foo)
# 指定
foo[2]
# 範囲指定
foo[2:] foo[2:4] foo[:3] foo[:]
```

## 組込関数

### make(型,要素数,容量)
```
x := make([]int, 10)  ->容量・要素数10int配列。０フィルされている。
y :~ make([]int,  10,15) -> 容量は15で定義される
```

### append(スライス名,追加データ,追加データ2 , ... , 追加データ{n} )
- 指定したスライス名（範囲指定可能）の末尾に追加データ群が追加されたかたちで返る。
- 返ったスライスを別の変数に入れたとき
	- 容量内の追加の場合、「返ったものを格納したスライス」の「元のスライス」から引用した部分は同じポインタ（メモリ番地）なので値が共有される。
	- 容量を超えて追加した場合、Go自身が容量を元の倍に増やし、ポインタを再配置する。そのため、「元のスライス」と「返ったものを格納したスライス」は異なるポインタを持ち値を共有しない。（要検証）

### copy(src,dest)
- 中身を共有しないコピーを行える


## ２次元のスライス
スライス in スライス

```
<pre>
A := [][]float64{{0,0}, {0, 1}, {1, 0}, {1, 1}}

B := make([][]float64, 4)
B[0] = []float64{1, 1}
</pre>

```
